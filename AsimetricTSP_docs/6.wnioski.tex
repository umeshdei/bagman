\section{Wnioski}

% Złożność algorytmów
\subsection{Złożoność obliczeniowa zaproponowanego algorytmu heurystycznego}

Zaproponowany przez autorów algorytm charakteryzuje się bardzo niewielkim
czasem wykonania obliczeń. Złożoność tą można bardzo łatwo wyznaczyć.
Działanie algorytmu opierasię, jak wspomniano we wstępie na wyborze
odpowiedniego punktu spośród dostępnych. Przy początkowym punkcie, gdy
dostępnych jest $n - 1$ punktów (ponieważ jeden już jest wykorzystany - 
został wylosowany). Spośród tych punktów należy wybrać minimum i
z nowego punktu ponownie wybrać najbliższy punkt na podstawie wag
poszczególnych łuków w grafie. Należy wykonać kolejno $n - 1$
takich operacji ze względu, na fakt że dla ostatniego 
wierzchołka takiej operacji wykonywać już nie trzeba. Prowadzi to do
złożoności kwadratowej, którą można opisać jako $ O(n^{2}) $.
Dla analizowanych małych instancji problemu komiwojażera, złożoność ta
skutkuje błyskawicznym czasem wykonywania obliczeń.

Warto zwrócić uwagę na fakt, iż można dokonać niewielkiej optymalizacji,
która wpradzie nie zmniejszy rzędu wielkości złożoności problemu, jednak
może skutkować nieznacznym zmniejszeniem złożoności. W przypadku gdy został
wybrany wierzchołek pewne jest, że nie może zostać on odwiedzony ponownie
dlatego możliwe jest usunięcie z macierzy odległości między
wierzchołkami usunięcie kolumny oraz wiersza powiązanych z
analizowanym wierzchołkiem. Jeżeli pominąć czas wykonania
operacji usuwania wierzy i kolumn, skutkowałoby to wykonaniem dla pierwszego
wierzchołka $n - 1$ operacji przy wyznaczaniu minimum, ale dla kolejnego
wierzchołka byłyoby tych elementów $n - 2$, a dla następnego $n - 3$.
Można zauważyć, że złożoność wyniosłaby wówczas $\frac{n \cdot (n - 1)}{2})$.
Złożoność jest więc określona, a więc wiadomo, że w jakim czasie
można się spodziewać rozwiązania takiego problemu.


wynikami można zauważyć bardzo którki czas działania prostej
heurystki zaproponowanej przez autorów. Jest to spowodowane kwadratową złożonością 
czasową $ O(n^{2}) $, ponieważ musimy $ n $ razy przejrzeć $ n $ punktów, aby znaleźć
nalbliższy. Otrzymujemy dzięki temu bardzo sybki algorytm. Jego wadą jest 
możliwość otrzymania wyniku bardzo oddalonego od optimum. Dzieje się tak dlatego, 
że przy końcowych obliczeniach nie mamy już dużego wyboru następnych odwiedzanych 
punktów, więc ostatnie ścieżki do wyboru mogę być bardzo długie. Wynik działania 
tego algorytmu mógłby być podstawą do uruchomienia algorymtów Steepest lub Greedy, 
które sprawdziłyby, czy w sąsiedztwie nie leżą lepsze rozwiązania. Znacznie skróciło
by to ich czas działania, poprzez start w miejscu, które jest blisko optimium.
Jest jednak możliwość, że punkt początkowy leżałby w pobliżu jakiegoś optimum 
lokalnego, i zawsze zwracany były ten sam wynik, uniemożliwiając odkrycie innych 
optimów i dzięki temu polepszenie wyniku.

\subsection{Odległość od optimum}

Przedstawione wyniki prezentują, że odległość od optimum dla wykonanych obliczeń 
są bardzo zróżnicowane. Najbardziej stalinie prezentuje się algorytm autorski 
dając średnio 20\% nadłożenie trasy. Algorytmy Steepest i Greedy lepiej działają dla 
większych instancji, przy małych natomiast znajdowane rozwiązania są dalekie od optimum
nawet ponad 2-krotnie.

Najbardziej zmienny jest algorytm losowy. Dane uzyskane za jego pomocą dla małych instancji
potrafią być bliskie optimum, a dla dużych instancji potrafiż byc bardzo odległe. Rozwiązanie
tego specyficznego zachowania zostało wytłumaczone poniżej.

\subsection{Uzyskane wyniki}

Pomiary jakości oraz szybkości wykonywania poszczególnych algorytmów
pozwalają stwierdzić, że najlepiej zarówno pod względem czasowym, jak i
jakościowym najlepiej poradził sie zaproponowany
przez autorów algorytm heurystyczny. Pozostałe algorytmy poradziły sobie
nieco gorzej. Najsłabsze rezultaty uzyskano w przypadku algorytmu
opartego o losowanie rozwiązań z całej przestrzeni rozwiązań dopuszczalnych.

\subsubsection{Zaproponowany algorytm heurystyczny}

 algorytmu autorskiego opiera się w dużej części na podejściu do problemu. 
Programowanie dynamiczne wybiera w daej chwili najbardziej optymalne rozwiązanie, 
dzięki czemu osiąga w ogólności bardzo dobre wyniki. Istnieją jednak sytuacje, gdy 
rozwiązania zaproponowane przez prosty algorytm heurystyczny może być ponad 2 razy 
gorsze od pozostałych algorytmów. Dzieje się tak w przypadku, gdy ostatnia wybrana 
trasa jest bardzo długa. Dlatego po otrzymaniu rozwiązania należałoby przejrzeć 
sąsiedztwo w poszukiawaniu rozwiązania lepszego umożliwiając, w niektórych przypadkach
usinięci najdłużeszej trasy.

\subsubsection{Algorytm Greedy i Steepest}

Wyniki uzyskane przez algorytm Greedy są lepsze niż uzyskane przez algorytm Steepest. 
Jest to spowodowane przechodzeniem do najlepszego rozwiązania przez algorytm Steepest. 
Dzięki temu wybiera on najczęściej ścieżkę do najbliższego optimum lokalnego. Algorytm
Greedy natomiast wybiera pierwsze znalezione rozwiązanie, które jest lepsze od dotychczas 
znalezionego. dzięki temu nie zbliża się gwałtownie do żadnego z optimów lokalnych, lecz 
raczej przeszukuje obszar tak długo, aż znajdzie ślepy zaułek.


\subsubsection{Algorytm losowy}

Jak wspomniano wczesniej, algorytm losowy zwracał najgorsze rozwiązania spośród
opisywanych algorytmów. Słabość tego algorytmu wiąże się z jego niedeterminizmem
oraz brak możliwości wykorzystania sprawdzonych rozwiązań do poprawy jakości
rozwiązań. Algorytm ten nie oferuje przeszukiwania lokalnego. Każde rozwiązanie
generowane jest od nowa, co skutkuje brakiem systematycznego przybliżania
się do optimum, zarówno lokalnego, jak i rozwiązania optymalnego.

W przypadku małych instancji danych wejściowych algorytm zwraca wyniki, które
dużo bardziej pasują do oczekiwanych rezultatów. Niestety wzrost rozmiaru
instancji powoduje, że otrzymywane rozwiązania stają się co raz gorsze
pomimo zwiększania ilości losowań. Taki stan rzeczy jest ściśle
związany z bardzo dużą przestrzenią rozwiązań, która rośnie wykładniczo
w zależności od rozmiaru instancji.

Prawdopodobieństwo znalezienia rozwiązania optymalnego przez algorytm
losowy w przypadku dużych instancji problemu wydaje się
być niemal zerowe. Liczba permutacji ustawień poszczególnych wierzchołków
z grafu danych wejściowych jest bardzo duża, a osiągnięcie odpowiednich
rezultatów wiązałoby się z ogromną ilością losowań, co byłoby niezmiernie
mało efektywne.

\subsection{Czas wykonywania algorytmów}

\it
W zestawieniu nie został ujęty prosty algorytm heurystyczny z poowdu zbyt krótkich czasów 
działania, dla 400 elementów nie został zmierzony (obliczenia pokazywały 0,00), podczas 
gdy najwolniejszy algorytm Steepest wymagał ponad 7 min.
\rm

\subsubsection{Algorytm Greedy}

Czas działania tego algorytmu dla większych instancji jest lepszy o ok. 50 - 70 \% w porównaniu 
do algorytmu Steepest. Pomimo, że potrzebuje on więcej iteracji, przejście do następnego kroku 
zajmuje mniej czasu, gdyż następuje od razu po znalezieniu lepszego rozwiązania. Jego złożoność 
wynosi następująco:

\subsubsection{Algorytm Steepest}

Algorytm ten jest ok. 2 razy gorszy od algorytmu Greedy.Wynika to głównie z fakty, że przegląda on
wszystkie rozwiązania zanim podejmie decyzję o następnym kroku. 

\subsubsection{Algorytm losowy}

Algorytm ten działa niederministycznie, dlatego potrafi osiągnąć szybsze czasy działania dla 
większych instancji. 

\subsection{Ilość iteracji}

Porównując ilość iteracji algorytmów Greedy i Steepest można zauważyć, że algorytm 
Steepest wykonyje ok. 4 razy mniej kroków od algorytmu Greedy. Jest to spowodowane 
dokładnym przeglądaniem przestrzeni sąsiedztwa i wybierania najleprzego rozwiązania.
